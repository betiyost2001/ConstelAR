diff --git a/backend/app/api/openaq.py b/backend/app/api/openaq.py
index d9bc2845df0b2d44eee87dd1f9d26407e968e1df..96524916f391f23b05c81388ee260c71bbe453c2 100644
--- a/backend/app/api/openaq.py
+++ b/backend/app/api/openaq.py
@@ -1,161 +1,357 @@
+"""NASA TEMPO air quality client and FastAPI router."""
+
+from __future__ import annotations
+
+import os
+from datetime import datetime, timedelta, timezone
+from typing import Any, Dict, Iterable, List, MutableMapping, Optional, Tuple
+
 import requests
 from fastapi import APIRouter, HTTPException, Query
 
-router = APIRouter()
-OAQ = "https://api.openaq.org/v2"
-OMQ = "https://air-quality-api.open-meteo.com/v1/air-quality"  # sin API key
-
-def _get(url, params):
-    r = requests.get(url, params=params, timeout=25)
-    r.raise_for_status()
-    return r.json()
-
-@router.get("/latest")
-def latest(
-    city: str | None = Query(None, description="City (opcional)"),
-    lat: float | None = Query(None, description="Latitude (opcional)"),
-    lon: float | None = Query(None, description="Longitude (opcional)"),
-    radius: int = Query(50_000, description="Radius meters (OpenAQ)"),
-    limit: int = Query(10, description="Limit"),
-):
-    # Preferimos coords si están
-    use_coords = (lat is not None and lon is not None)
 
-    # ----- INTENTO 1: OpenAQ /latest -----
-    try:
-        if use_coords:
-            q = {"coordinates": f"{lat},{lon}", "radius": radius, "limit": limit}
-        elif city:
-            q = {"city": city, "limit": limit}
-        else:
-            q = {"coordinates": "34.0522,-118.2437", "radius": radius, "limit": limit}
-        data = _get(f"{OAQ}/latest", q)
-        return {"source": "openaq/latest", "query": q, "data": data}
-    except requests.HTTPError as e:
-        status = getattr(e.response, "status_code", None)
-        if status not in (400, 404, 410, 422):
-            # errores de red/500 → cortar
-            raise HTTPException(status_code=502, detail=f"OpenAQ error: {e}") from e
-
-    # ----- INTENTO 2: OpenAQ /measurements -----
-    try:
-        mq = {"limit": limit, "order_by": "datetime", "sort": "desc"}
-        if use_coords:
-            mq.update({"coordinates": f"{lat},{lon}", "radius": radius})
-        elif city:
-            mq.update({"city": city})
-        else:
-            mq.update({"coordinates": "34.0522,-118.2437", "radius": radius})
-        mdata = _get(f"{OAQ}/measurements", mq)
-        return {"source": "openaq/measurements", "query": mq, "data": mdata}
-    except requests.HTTPError as e2:
-        status2 = getattr(e2.response, "status_code", None)
-        if status2 not in (400, 404, 410, 422):
-            raise HTTPException(status_code=502, detail=f"OpenAQ fallback error: {e2}") from e2
-
-    # ----- INTENTO 3: Open-Meteo Air Quality (sin API key) -----
-    # Requiere SI o SI lat/lon → si no vinieron, usa LA por defecto
-    qlat = lat if lat is not None else 34.0522
-    qlon = lon if lon is not None else -118.2437
-    om_params = {
-        "latitude": qlat,
-        "longitude": qlon,
-        "hourly": "pm10,pm2_5,carbon_monoxide,nitrogen_dioxide,sulphur_dioxide,ozone,aerosol_optical_depth,dust",
-        "past_days": 1,
-        "forecast_days": 0
-    }
+class EarthdataAuthError(RuntimeError):
+    """Raised when Earthdata authentication fails."""
+
+
+class NasaTempoInvalidQuery(ValueError):
+    """Raised when the query sent to the NASA TEMPO API is invalid."""
+
+
+class NasaTempoServiceError(RuntimeError):
+    """Raised for unexpected NASA TEMPO service errors."""
+
+
+def _env(name: str) -> Optional[str]:
+    value = os.getenv(name)
+    if value:
+        value = value.strip()
+    return value or None
+
+
+def _default_time_range() -> Tuple[datetime, datetime]:
+    """Return the default [start, end] time range (last 24 hours UTC)."""
+
+    end = datetime.now(timezone.utc)
+    start = end - timedelta(hours=24)
+    return start, end
+
+
+def _parse_bbox(bbox: str) -> Tuple[float, float, float, float]:
     try:
-        om = _get(OMQ, om_params)
-        # normalizamos una respuesta compacta (último dato horario disponible)
-        hourly = om.get("hourly", {})
-        # tomar la última entrada disponible por contaminante
-        out = []
-        if "time" in hourly and hourly["time"]:
-            idx = len(hourly["time"]) - 1
-            for key in ["pm2_5", "pm10", "ozone", "nitrogen_dioxide", "sulphur_dioxide", "carbon_monoxide"]:
-                if key in hourly and len(hourly[key]) > idx and hourly[key][idx] is not None:
-                    out.append({
-                        "parameter": key,
-                        "value": hourly[key][idx],
-                        "datetime": hourly["time"][idx],
-                        "coordinates": {"latitude": qlat, "longitude": qlon}
-                    })
-        return {"source": "open-meteo/air-quality", "query": om_params, "data": {"results": out}}
-    except requests.RequestException as e3:
-        raise HTTPException(status_code=502, detail=f"Open-Meteo error: {e3}") from e3
-# --- helpers arriba del router.normalized (podés ponerlos junto a _get) ---
-def _normalize_openaq_measurements(items):
-    norm = []
-    for r in items:
+        parts = [float(p.strip()) for p in bbox.split(",")]
+    except ValueError as exc:  # non numeric
+        raise NasaTempoInvalidQuery(
+            "BBox must contain comma separated numeric values"
+        ) from exc
+
+    if len(parts) != 4:
+        raise NasaTempoInvalidQuery(
+            "BBox must contain exactly four numbers: minLon,minLat,maxLon,maxLat"
+        )
+
+    min_lon, min_lat, max_lon, max_lat = parts
+    if min_lon >= max_lon or min_lat >= max_lat:
+        raise NasaTempoInvalidQuery(
+            "BBox coordinates are not valid (check min/max values)"
+        )
+
+    return min_lon, min_lat, max_lon, max_lat
+
+
+def _format_datetime(value: datetime | None) -> Optional[str]:
+    if value is None:
+        return None
+    if value.tzinfo is None:
+        # Assume UTC if no timezone supplied
+        value = value.replace(tzinfo=timezone.utc)
+    return value.astimezone(timezone.utc).isoformat().replace("+00:00", "Z")
+
+
+class NasaTempoClient:
+    """HTTP client to interact with NASA TEMPO API endpoints."""
+
+    def __init__(
+        self,
+        base_url: Optional[str] = None,
+        dataset: Optional[str] = None,
+        timeout: float | int = 30,
+        session: Optional[requests.Session] = None,
+    ) -> None:
+        self.base_url = (
+            base_url
+            or _env("NASA_TEMPO_BASE_URL")
+            or "https://harmony.earthdata.nasa.gov/tempo"
+        ).rstrip("/")
+        self.dataset = dataset or _env("NASA_TEMPO_DATASET") or "tempo_no2_l2_reduced"
+        self.timeout = float(timeout)
+        self.session = session or requests.Session()
+        token = (
+            _env("EARTHDATA_TOKEN")
+            or _env("NASA_EARTHDATA_TOKEN")
+            or _env("HARMONY_AUTH_TOKEN")
+        )
+        self._token = token
+
+        username = _env("EARTHDATA_USERNAME")
+        password = _env("EARTHDATA_PASSWORD")
+        if username and password:
+            self.session.auth = (username, password)
+
+        self._api_key = _env("NASA_TEMPO_API_KEY")
+
+    def _headers(self) -> Dict[str, str]:
+        headers: Dict[str, str] = {"Accept": "application/json"}
+        if self._token:
+            headers["Authorization"] = f"Bearer {self._token}"
+        if self._api_key:
+            headers["X-Api-Key"] = self._api_key
+        return headers
+
+    def _request(
+        self, method: str, path: str, params: MutableMapping[str, Any]
+    ) -> Dict[str, Any]:
+        url = f"{self.base_url}/{path.lstrip('/')}"
+        try:
+            response = self.session.request(
+                method,
+                url,
+                params=params,
+                headers=self._headers(),
+                timeout=self.timeout,
+            )
+        except requests.Timeout as exc:
+            raise NasaTempoServiceError("NASA TEMPO service timeout") from exc
+        except requests.RequestException as exc:
+            raise NasaTempoServiceError(
+                f"NASA TEMPO service connection error: {exc}"
+            ) from exc
+
+        if response.status_code in (401, 403):
+            raise EarthdataAuthError(
+                "NASA Earthdata authentication failed (check token/credentials)"
+            )
+        if response.status_code == 404:
+            raise NasaTempoInvalidQuery("Requested NASA TEMPO resource was not found")
+        if response.status_code >= 400:
+            raise NasaTempoServiceError(
+                f"NASA TEMPO service error {response.status_code}: {response.text.strip() or response.reason}"
+            )
+
         try:
-            norm.append({
-                "lat": r["coordinates"]["latitude"],
-                "lon": r["coordinates"]["longitude"],
-                "parameter": r["parameter"],
-                "value": r["value"],
-                "unit": r.get("unit", ""),
-                "datetime": r["date"]["utc"],
-            })
-        except KeyError:
+            data: Dict[str, Any] = response.json()
+        except ValueError as exc:
+            raise NasaTempoServiceError(
+                "NASA TEMPO response is not valid JSON"
+            ) from exc
+
+        return data
+
+    def measurements(
+        self,
+        *,
+        parameter: str,
+        limit: int,
+        start: Optional[datetime] = None,
+        end: Optional[datetime] = None,
+        lat: Optional[float] = None,
+        lon: Optional[float] = None,
+        radius_km: Optional[float] = None,
+        bbox: Optional[Tuple[float, float, float, float]] = None,
+    ) -> Dict[str, Any]:
+        if bbox is None and (lat is None or lon is None):
+            raise NasaTempoInvalidQuery(
+                "Provide either latitude/longitude or a bounding box"
+            )
+
+        params: Dict[str, Any] = {
+            "parameter": parameter,
+            "limit": max(1, min(limit, 500)),
+            "dataset": self.dataset,
+        }
+
+        start_iso = _format_datetime(start)
+        end_iso = _format_datetime(end)
+        if start_iso:
+            params["start"] = start_iso
+        if end_iso:
+            params["end"] = end_iso
+
+        if bbox is not None:
+            params["bbox"] = ",".join(str(x) for x in bbox)
+        else:
+            params["latitude"] = lat
+            params["longitude"] = lon
+            if radius_km is not None:
+                params["radius"] = float(radius_km)
+
+        # Harmony exposes an observations endpoint for gridded subsets.
+        # Documentation references: https://harmony.earthdata.nasa.gov/
+        return self._request("GET", "observations", params)
+
+
+def _extract_candidate_iterable(payload: Dict[str, Any]) -> Iterable[Dict[str, Any]]:
+    for key in ("observations", "results", "features", "items", "data"):
+        value = payload.get(key)
+        if isinstance(value, list):
+            return value
+    # Some responses embed observations under a "properties" object
+    if "properties" in payload and isinstance(payload["properties"], dict):
+        inner = payload["properties"].get("observations")
+        if isinstance(inner, list):
+            return inner
+    return []
+
+
+def _normalize_measurements(
+    payload: Dict[str, Any],
+    *,
+    fallback_parameter: str,
+    limit: int,
+) -> List[Dict[str, Any]]:
+    items = _extract_candidate_iterable(payload)
+    normalized: List[Dict[str, Any]] = []
+
+    for item in items:
+        if not isinstance(item, dict):
+            continue
+
+        props: Dict[str, Any] = (
+            item.get("properties", {})
+            if isinstance(item.get("properties"), dict)
+            else {}
+        )
+        geom = item.get("geometry") if isinstance(item.get("geometry"), dict) else {}
+
+        coords = (
+            geom.get("coordinates")
+            if isinstance(geom.get("coordinates"), (list, tuple))
+            else None
+        )
+        lat = props.get("latitude")
+        lon = props.get("longitude")
+        if lat is None and coords and len(coords) >= 2:
+            lon = coords[0]
+            lat = coords[1]
+        elif lon is None and coords and len(coords) >= 2:
+            lon = coords[0]
+
+        parameter = (
+            props.get("parameter") or item.get("parameter") or fallback_parameter
+        )
+
+        # Determine the value and units.
+        value = (
+            props.get("value")
+            or props.get("measurement")
+            or props.get("average")
+            or props.get("mean")
+            or item.get("value")
+            or item.get("measurement")
+        )
+
+        unit = props.get("unit") or props.get("units") or item.get("unit") or ""
+
+        dt = (
+            props.get("time")
+            or props.get("datetime")
+            or props.get("timestamp")
+            or props.get("start_time")
+            or props.get("start_datetime")
+            or item.get("datetime")
+            or item.get("time")
+        )
+
+        if lat is None or lon is None or value is None or dt is None:
             continue
-    return norm
-
-def _fetch_openmeteo(lat, lon, limit):
-    om_params = {
-        "latitude": lat,
-        "longitude": lon,
-        "hourly": "pm2_5,pm10,ozone",
-        "past_days": 0,
-        "forecast_days": 1,
-    }
-    raw = _get(OMQ, om_params)
-    results = []
-    hourly = raw.get("hourly", {})
-    times = hourly.get("time", []) or []
-    for i, t in enumerate(times):
-        for param in ["pm2_5", "pm10", "ozone"]:
-            serie = hourly.get(param, [])
-            if i < len(serie) and serie[i] is not None:
-                results.append({
-                    "lat": lat,
-                    "lon": lon,
-                    "parameter": param,
-                    "value": serie[i],
-                    "unit": "µg/m³",
-                    "datetime": t,
-                })
-    return {"source": "open-meteo/air-quality", "results": results[:limit]}
-
-# --- endpoint normalized (reemplaza el tuyo) ---
+
+        normalized.append(
+            [
+                float(lat),
+                float(lon),
+                str(parameter),
+                value,
+                unit,
+                dt,
+            ]
+        )
+
+        if len(normalized) >= limit:
+            break
+
+    return normalized
+
+
+router = APIRouter(tags=["NASA TEMPO"])
+client = NasaTempoClient()
+
+
 @router.get("/normalized")
 def normalized(
-    lat: float = Query(-31.4201, description="Latitude"),
-    lon: float = Query(-64.1888, description="Longitude"),
-    radius: int = Query(50_000, description="Radius meters (OpenAQ)"),
-    limit: int = Query(10, description="Limit"),
-    city: str | None = Query(None, description="City (optional)"),
+    parameter: str = Query(
+        "no2", description="Pollutant parameter identifier (e.g. no2, o3, so2)"
+    ),
+    lat: Optional[float] = Query(None, description="Latitude for point queries"),
+    lon: Optional[float] = Query(None, description="Longitude for point queries"),
+    bbox: Optional[str] = Query(
+        None,
+        description="Bounding box as minLon,minLat,maxLon,maxLat (overrides lat/lon if provided)",
+    ),
+    radius_km: Optional[float] = Query(
+        None,
+        description="Radius in kilometers around the point location (when using lat/lon)",
+        ge=0.0,
+    ),
+    start: Optional[datetime] = Query(
+        None,
+        description="Start datetime (UTC). Defaults to 24 hours before `end`.",
+    ),
+    end: Optional[datetime] = Query(
+        None, description="End datetime (UTC). Defaults to now."
+    ),
+    limit: int = Query(
+        50, ge=1, le=500, description="Maximum number of measurements to return"
+    ),
 ):
-    """
-    Devuelve mediciones normalizadas:
-    [{lat, lon, parameter, value, unit, datetime}]
-    Intenta OpenAQ (/measurements) por coords o city; si 0 resultados, fallback a Open‑Meteo.
-    """
-    # 1) OpenAQ /measurements (ordena por datetime desc)
-    try:
-        mq = {"limit": limit, "order_by": "datetime", "sort": "desc"}
-        if city:
-            mq["city"] = city
-        else:
-            mq.update({"coordinates": f"{lat},{lon}", "radius": radius})
+    """Return normalized TEMPO pollutant measurements for a location or bounding box."""
+
+    bbox_tuple: Optional[Tuple[float, float, float, float]] = None
+    if bbox:
+        try:
+            bbox_tuple = _parse_bbox(bbox)
+        except NasaTempoInvalidQuery as exc:
+            raise HTTPException(status_code=422, detail=str(exc)) from exc
+
+    if bbox_tuple is None and (lat is None or lon is None):
+        raise HTTPException(status_code=422, detail="Provide either lat/lon or bbox")
 
-        mdata = _get(f"{OAQ}/measurements", mq)
-        oa_results = _normalize_openaq_measurements(mdata.get("results", []))
-    except requests.RequestException:
-        oa_results = []
+    if end is None:
+        _, default_end = _default_time_range()
+        end = default_end
+    if start is None:
+        default_start, _ = _default_time_range()
+        start = default_start
+
+    try:
+        payload = client.measurements(
+            parameter=parameter,
+            limit=limit,
+            start=start,
+            end=end,
+            lat=lat,
+            lon=lon,
+            radius_km=radius_km,
+            bbox=bbox_tuple,
+        )
+    except NasaTempoInvalidQuery as exc:
+        raise HTTPException(status_code=422, detail=str(exc)) from exc
+    except EarthdataAuthError as exc:
+        raise HTTPException(status_code=401, detail=str(exc)) from exc
+    except NasaTempoServiceError as exc:
+        raise HTTPException(status_code=502, detail=str(exc)) from exc
 
-    # 2) Si OpenAQ trajo algo, devolver
-    if oa_results:
-        return {"source": "openaq/measurements", "results": oa_results[:limit]}
+    results = _normalize_measurements(
+        payload, fallback_parameter=parameter, limit=limit
+    )
 
-    # 3) Fallback a Open‑Meteo si no hay resultados
-    return _fetch_openmeteo(lat, lon, limit)
+    return {"source": "nasa-tempo", "results": results}
